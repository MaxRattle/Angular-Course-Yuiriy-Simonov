Модуль - изолированный логический блок, который может объединить различный логический функционал, зависит от того какие структурные элементы(более мелкие сервисы,компоненты, директивы) в него входят. Пример модуля: модуль routing.

Компонент - часть интерфейса приложения со своей логикой и функциональностью. Компонент должен принадлежать какому-нибудь модулю.

                                    Схема:
                              Angular 2 bootstrapper
                                       |
                                    Module
                                (Root components)
                              /                 \
                            Module             Module
                          (Component)         (Component)
                        /             \            |
                      Module         Module    Component
                    (Component)    (Component)
Основные:
Декораторы обозначаются с @
@NgModule - декоратор модуля
@Component -  декоратор компонента
@Injectable - декоратор сервиса
@Directive - декоратор директивы

Правила задания имен классов и файлов:
---
MyBestComponent
MyBest - пользовательское название, Component - название сущности
---
AppModule
App - пользовательское название, Module - название сущности
---
pipes-example.pipe.ts
pipes-example - пользовательское название, pipe - название сущности, ts - расширение файла
если есть: spec - указатель, что файлов для тестов
------
Разница между Pure и Impure Angular Pipes (чистыми и грязными пайпами)
в @Pipe мы можем дописат параметр pure: true, это значит (например у нас пайп сортировки массива) что объект на который вызывается пайп не будет обновлен (в нашем примере если мы запушим еще один элемент, к нему не будет добавлено свойство сортировки автоматически => не будет автоматической пересортировки)
если же указать pure: false тогда будет автоматически применен пайп (динамически) к объекту.
Чтобы не изменять значения pure, мы может сделать так (использовать деструктаризацию):
  newArr = setTimeout(() => {
    this.ageOfUsers = [...this.ageOfUsers, { age: -999 }];
  }, 3000);
------
<app-child [childColor]="color"></app-child>
 @Input() childColor: string
 работает на один уровень вложенности
--
если названия @Input не совпадает тогда заносим это название:
@Input('childColor') childColorProps!: string;

чтобы убрать ошибку нужно объявить @Input (добавить восклицательный знак): @Input('childColorProps') childColorProps!: string;
-------
Чтобы отобразить контент внутри app-componet тега, нужно в child добавить <ng-content>
select видит только первый уровень вложенности
-------
ng-container имитация обертки котоаря не изменяет DOM дерево
-------
директивы *ngFor, *ngIf, *ngSwitchCase
-------
нельзя использовать более двух директив к одному элементу DOM дерева
------
Атрибутивные директивы стилизации
ngClass и ngStyle
если просто записать ngClass="aqua" это равносильно clas="aqua"
если условие правдиво класс будет присутствовать на элементе {'green':true, colorClass: false}
ngStyle работает с онлайновыми стилями а не с CSS
в ngStyle записывается так: Свойство Css:параметр(например поле из класса компонента), пример: [ngStyle]="{color: colorClass}"
поле может например быть объектом свойств CSS: colorClass={color:'green', background-color:'yellow'} однако синтаксис будет без интерполяции:
[ngStyle]="colorClassObj";
обычный [style] тоже принимает такой фомрат
------
Angular 17:
директивы тепер ьвыглядит @if, @for, @switch
В целом новый синтаксис удобнее, особенно когда много условий
В новом синтаксисе в switch есть break, в старом он выполнит все условия
